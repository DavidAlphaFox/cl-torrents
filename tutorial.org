#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:t html-style:t
#+OPTIONS: html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION: Scraping the Pirate Bay in Common Lisp
#+KEYWORDS: common lisp web-scraping pirate-bay
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 9.0.3)
#+LATEX_HEADER:

#+AUTHOR: vindarel

#+SETUPFILE: theme-readtheorg.setup


* Make it work

Scraping   The   Pirate   Bay   is    easy,   they   don't   rely   on
javascript-generated pages. We just have to:

- get the html page ([[http://quickdocs.org/dexador/][dexador]]: =(dex:get <url>)=)
- parse the html into a data structure ([[https://shinmera.github.io/plump/][plump]]: =(plump:parse <html>)=)
- search   with  CSS   selectors  ([[https://shinmera.github.io/lquery][lquery]]:   =(lquery:"  <parsed-html>
  <selectors>)=)

We suppose  you have a  ready Common Lisp development  environment. If
not, see the [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][Cookbook/getting-started]] (and  if that's not enough, fill
an issue !).

Let's go.

Install our dependencies right away:

#+BEGIN_SRC lisp
(ql:quickload '("dexador" "plump" "lquery"))
#+END_SRC

To begin  with, we do  a search on the  website and we  copy-paste the
url. We get one like this:

#+BEGIN_SRC lisp
(defparameter *search-url* "https://piratebay.to/search/?FilterStr=matrix&ID=&Limit=800&Letter=&Sorting=DSeeder"
    "the url to search matrix.")
#+END_SRC

It has our search term in it (=matrix=) along with url parameters.

It also sorts the results by number of seeders for us :) (=&Sorting=DSeeder=).

We will use CSS selectors to extract information from the web page, so
we can use  our browser's developer tools to inspect  the structure of
the page  and guess our  selectors: right  click on a  result's title,
choose "inspect element". It highlights some html similar to this:

#+BEGIN_SRC html
  <td class="Title">
    <span class="ColorA">
      <a href="https://piratebay.to/torrent/1922147/Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438/" onclick="Javascript:OpenDetailPage('https://piratebay.to/torrent/1922147/Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438/'); return false;">Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438 </a>
    </span>
    <br>
      <span class="ColorB VaA">Upload Date: 20.02.15 </span>
      <span class="ColorB VaA">Size: 796,86 MB </span>
      <span class="ColorB"> </span>
  </td>
#+END_SRC


The title is  well delimited so we'll start selecting  our elements by
the CSS class =Title=, which gives:

#+BEGIN_SRC lisp
(defparameter *selectors* ".Title")
#+END_SRC

If  you are  not accostumed  to  CSS selectors,  this post  is a  nice
helper:
https://codingsec.net/2016/12/select-specific-text-css-using-selectors/.

** Trying out at the REPL

Let's try in the REPL:

#+BEGIN_SRC lisp
(defparameter html (dex:get *search-url*)) ;; returns the html
(defparameter parsed (plump:parse html))   ;; returns a list of plump elements
(defparameter results (lquery:$ parsed *selectors*)) ;; returns a list of stuff
(setf results (lquery:$ parsed *selectors* (text)))  ;; returns text, i.e. the titles
#+END_SRC

A little explanation for the =lquery=  line: the last =(text)= part is
an lquery thing to get the text representation of the node, instead of
a  lquery internal  object.  Likewise  we'll be  able  to call  =(attr
:href)=  or  =(html)=, which  are  self-explanatory.  If you  want  CL
symbols there, use =(inline (...))=.

I  like to  check the  html content  of the  plump nodes.  We use  the
=serialize= plump function (the second function from the doc ;) ):

#+BEGIN_SRC lisp
CL-TORRENTS> (plump:serialize (first results))
#+END_SRC

but we get an error:

#+BEGIN_QUOTE
The value #(
... all the content of results here ...
)
is not of type LIST
…
#+END_QUOTE

Sorry for  the inconvenience. Indeed, lquery  returns a vector,
not a list (we  can see that with =#()= that denotes  a vector), so we
can not use =first= but have to use =(aref <vector> 0)= instead, or we
have to =coerce= the result to a list.

(see the [[https://lispcookbook.github.io/cl-cookbook/data-structures.html][Cookbook's Data Structures page]]).

Personnally I find this frustrating, particularly being used in Python
to access  lots of data  structures in the  same manner.  If  you feel
like  fixing this,  have a  look at  [[https://lispcookbook.github.io/cl-cookbook/cl21.html][CL21]], "Common  Lisp for  the 21st
century" which,  amongst other  features, redefines some  functions to
make them generic (that work on lists, vectors, hashmaps,…). CL21 is a
CL library, meaning we can of  course use the others CL libraries with
it, or that  we can use cl21  alongside CL in only in  some places but
not in all our project (like in only one file, one "package").

It is written  by a super productive and innovative  CL hacker and has
600+ stars  on github.  Nevertheless,  it wasn't touched in  two years
and, as it lacks docstrings and  direction, we can be surprised by the
new implementation  of some  functions (see  its issues).  Some people
discourage the use of it.  I, at least, am a happy user for the moment
:)

Allright so, back to printing the html content of our first result:

#+BEGIN_SRC text
CL-TORRENTS> (plump:serialize (aref results 0))
<th class="Title header ">
<a href="https://piratebay.to/search/0/800/0/matrix/0/ATitle/1/">Title</a>
</th>
">"
#+END_SRC

gosh, there  is not much in  it.  I was  too quick in defining  my CSS
selector.  This  first result should  not be catched by  our selector,
because it is not a link to a torrent but only the header of the table
(see "Title header" and the =th= ?).

But that's not  all. I also want  to scrape the number  of seeders and
leechers and  the =.Title= selector  doesn't include them  (this I see
with the browser's web inspector). If I select the including =tr= I'll
get all the data,  and I must ensure to select  those =tr= from inside
the body  of the table,  =tbody=.  So I'll  use a first  selector that
will return a list of elements of the table:

#+BEGIN_SRC lisp
(setf *selectors* "tbody tr")
#+END_SRC

and then for each result I'll get the title and the number of seeders.

So I can scrape again my search results with the new selector:

#+BEGIN_SRC lisp
(setf results (lquery:$ parsed *selectors* (text)))
#+END_SRC

this should print interesting stuff, like our torrents titles and even
strings like =S: 16L: 1= which are indeed our seeders and leechers.

I check the html content and it seems allright. It has the link to the
torrent's page  inside the  href of  the "a" element,  as well  as the
seeders count.

Note that we  can also inspect the results with  the mouse: left/right
clicks  on the  elements printed  in the  REPL get  us into  the Slime
inspector.

** Putting it together in a function

We came up with this function:

#+BEGIN_SRC lisp
(defun torrents (words)
  ""
  (let* ((html (dex:get *search-url*))
         (parsed (plump:parse html))
         (res (lquery:$ parsed *selectors* (text))))
    res))
#+END_SRC

and if  you prefer a  threading macro /  pipes, no problem,  but we'll
load another external library:

#+BEGIN_EXPORT latex
(ql:quickload "cl-arrows")
;; and we import its symbols:
(use-package "cl-arrows")
#+END_EXPORT

#+BEGIN_SRC lisp
(-<>> *search-url*
  (dex:get)
  (plump:parse)
  (lquery:$ <> *selectors* (text)))
#+END_SRC

[[https://github.com/nightfly19/cl-arrows][cl-arrows]] defines  a few  threading macros. The  classic one  would be
=->=,  which inserts  the  result  of the  preceding  form as  _first_
argument, =->>= that  puts it _last_, which is what  we wanted for the
two  forms but  not for  the last  one, with  lquery, which  needs the
parsed  html as  first argument.   So we  use =-<>>=:  the arrow  will
populate  the  _last_  argument,  except when  it  encounters  a  =<>=
placeholder. =-<>>= has a little name, "Diamond Spear".

** Creating a new project

   Before we write more functions we  should create a new project. For
   this  I  use a  skeleton  generator  which  will create  the  right
   =defsystem=, =defpackage= and so for us.

 I use  =cl-project=, which  also generates a  tests skeleton  (in the
 contrary of =quick-project=):

 #+BEGIN_SRC lisp
 (ql:quickload "cl-project")
 (cl-project:make-project #P"~/path/to/cl-torrents/")
 #+END_SRC

 Note that it  may be easier for  you sometimes if you  create your new
 Common  Lisp  projects  into =~/.quicklisp/local-projects=  (known  by
 Quicklisp)  or =~/.local/share/common-lisp/=  (known by  ASDF). Doing
 so, you will be able to =ql:quickload= your project right away.

** Adding our dependencies

Our new =cl-torrents.asd= looks like this:

#+BEGIN_SRC lisp
#|
  This file is a part of cl-torrents project.
|#

(in-package :cl-user)
(defpackage cl-torrents-asd
  (:use :cl :asdf))
(in-package :cl-torrents-asd)

(defsystem cl-torrents
  :version "0.1"
  :author ""
  :license ""
  :depends-on ()  ;; <== list of dependencies
  :components ((:module "src"
                :components
                ((:file "cl-torrents"))))
  :description ""
  :long-description
  …)
#+END_SRC

For pythonistas, it is very similar to a =setup.py=.

It  has the  =depends-on= paramater  which accepts  a list  of package
names. We have to register here =dexador= and the others:

#+BEGIN_SRC lisp
  :depends-on (:str
               :dexador
               :plump
               :lquery)
#+END_SRC

and =cl-arrows= if you wish.

** Loading the project

Open the  =.asdf= file and  compile and load  it. In Slime,  it's with
=C-c C-k= (=slime-compile-and-load-file=, see also the Emacs menu).

Now we can load the project at the REPL and install its dependencies:

#+BEGIN_SRC lisp
(ql:quickload "cl-torrents" ;; or asdf:make
; compiling file "/home/vince/projets/cl-torrents/src/cl-torrents.lisp" (written 28 AUG 2017 10:21:07 PM):
; compiling (IN-PACKAGE :CL-USER)
; compiling (DEFPACKAGE CL-TORRENTS ...)
; compiling (IN-PACKAGE :CL-TORRENTS)
; compiling (DEFPARAMETER *SEARCH-URL* ...)
; compiling (DEFPARAMETER *SELECTORS* ...)
; compiling (DEFUN TORRENTS ...)

; /home/vince/.cache/common-lisp/sbcl-1.3.19-linux-x64/home/vince/projets/cl-torrents/src/cl-torrents-tmp5GEXGEG5.fasl written
; compilation finished in 0:00:00.029
; compilation unit finished
T
#+END_SRC

And now we can use our function at the REPL.

We go into our package so that we can call our functions directly:

#+BEGIN_SRC lisp
(in-package :cl-torrents)
#+END_SRC

We could import the functions from our package and call them directly,
but we need to =export= them and we'll see that shortly.

We could  call them  with the  project prefix, but  we need  a doublon
colon because  our functions  are not exported  yet (so  they're kinda
private,  but not  strictly,  like  with a  method  starting with  the
underscore =_= in Python).

#+BEGIN_SRC lisp
(cl-torrents::torrents "matrix")
#+END_SRC

** Searching with our keywords

Until now  we only tried  things out with a  given search url,  set in
stone. It's time to insert our own search terms into this search url.

We'll put a ={KEYWORDS}= placeholder into the url:

#+BEGIN_SRC lisp
(defparameter *search-url* "https://piratebay.to/search/?FilterStr={KEYWORDS}&ID=&Limit=800&Letter=&Sorting=DSeeder"
    "base search url. {KEYWORDS} to be replaced by + separated words.")
#+END_SRC

which we will replace with a =+=-separated list of keywords.

With a little  look at the [[https://lispcookbook.github.io/cl-cookbook/strings.html]["strings" cookbook page]],  we'll go with the
little [[https://github.com/vindarel/cl-str][str]] library (our lib actually):

#+BEGIN_SRC lisp
(ql:quickload "str") ;; not needed if you loaded the asdf with the right dependencies.
#+END_SRC

Let's try:

#+BEGIN_SRC lisp
(defparameter words "matrix trilogy")
;; => WORDS
(str:words words)
;; => ("matrix" "trilogy")
(str:join "+" *) ;; the * is a REPL shortcut to insert the previous result. + inserts the previous input.
;; => "matrix+trilogy"
#+END_SRC

and voilà. We put this at the beginning of our search function and we get:

#+BEGIN_SRC lisp
(defparameter *search-url* "https://piratebay.to/search/?FilterStr={KEYWORDS}&ID=&Limit=800&Letter=&Sorting=DSeeder" "base search url. KEYWORDS to be replaced.")

(defun torrents (words)
  "Search torrents."
  (let* ((terms (str:words words))
         (query (str:join "+" terms))
         (*search-url* (str:replace-all "{KEYWORDS}" query *search-url*))
         (req (dex:get *search-url*))
         (html (plump:parse req))
         (res (lquery:$ html *selectors* (text)))
         (res-list (coerce res 'list))))

    res-list))
#+END_SRC

In the end we prefer to return a list, rather than a vector.

Let's try:

#+BEGIN_SRC lisp
(torrents "matrix trilogy")
#("Matrix FRENCH DVDRIP 1999 COOLUpload Date: 05.06.15 Size: 700,30 MB"
  "The Matrix Reloaded (2003) FullHD, Dual Audio: English + SpaUpload Date: 12.04.15 Size: 8,51 GB"
  "The Matrix Trilogy (1999-2003) + Extras 1080p BluRay x264 DuUpload Date: 12.02.15 Size: 12,86 GB"
  "The Matrix Trilogy (1999-2003) BluRay BDRip 1080p AC3Upload Date: 15.09.15 Size: 23,29 GB"
  "The Matrix Trilogy (1999-2003) BDRip 1080p Dual Audio [ HindUpload Date: 14.01.15 Size: 10,23 GB"
  "The Matrix Revolutions (2003) BRRip [Dual Audio] [Hindi+Eng]Upload Date: 24.02.15 Size: 496,36 MB"
  "Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438Upload Date: 20.02.15 Size: 796,86 MB"
  "The Matrix Reloaded (2003) BRRip [Dual Audio] [Hindi+Eng] 50Upload Date: 22.02.15 Size: 496,39 MB"
  [and more results]
#+END_SRC

Cool !

We can commit  this, have a break  and enjoy how things  are going. It
was very easy, except one or two gotchas :)

Of course, we need  to get more stuff out of  this, like the torrent's
magnet link.

** Formatting output

   Our  =torrents= function  prints  out intelligable  output, but  we
   don't control  it yet. We want  to iterate over the  search results
   and print exactly what we want.

   So first  we need to  extract the title,  with the CSS  selector we
   found at the beginning.

#+BEGIN_SRC lisp
(defun result-title (node)
  "Return the title of a search result."
  (aref
   (lquery:$ node ".Title a" (text))
   0))
#+END_SRC

    When we iterate over the result list:

#+BEGIN_SRC lisp
(defun display-results (&optional (results *last-search*) (stream t))
  "Results: list of plump nodes. We want to print a numbered list with the needed information (torrent title, the number of seeders,..."
  (mapcar (lambda (it)
            ;; do not rely on *last-search*.
            (format stream "~a~%" (result-title it)))
          results)
  t)
#+END_SRC

    it prints something like:

#+BEGIN_SRC text
Matrix FRENCH DVDRIP 1999 COOL
The Matrix Reloaded (2003) FullHD, Dual Audio: English + Spa
The Matrix Trilogy (1999-2003) + Extras 1080p BluRay x264 Du
The Matrix Trilogy (1999-2003) BluRay BDRip 1080p AC3
The Matrix Trilogy (1999-2003) BDRip 1080p Dual Audio [ Hind
Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438
...
#+END_SRC

    What we have in  mind is to print the index of  the result next to
    it, and for convenience to print the first result last, so that it
    stays to the bottom and it's easier to see from the prompt.

    We have  a quick look at  the [[https://lispcookbook.github.io/cl-cookbook/strings.html#string-formatting][Cookbook for string  formatting]] (the
    simplest directive is =~a=, for aesthetics, and justifying text on
    the left is with =~@a=). =~%= is the newline.

#+BEGIN_SRC lisp
(defun display-results (&optional (results *last-search*) (stream t))
  "Results: list of plump nodes. We want to print a numbered list with the needed information (torrent title, the number of seeders,..."
  (mapcar (lambda (it)
            (format stream "~3@a: ~65a ~%"
                    (position it *last-search*) ;; <-- find the position of the result in the list
                    (result-title it)))  ;; <-- we reverse the list
          (reverse results))

          t)
#+END_SRC

Here we use another global  variable that we introduced eventually. In
the end of  our =torrents= function, we add this:

#+BEGIN_SRC lisp
    (setf *last-search* res-list)
#+END_SRC

so that our search results are saved in this variable which we define:

#+BEGIN_SRC
(defvar *last-search* nil
    "Remembering the last search (should be an hash-map).")
#+END_SRC

and we can easily access this result list elsewhere.


So, we get this formatting:

#+BEGIN_SRC text
198: Arturia - Matrix-12 V v1.1.0.522 OS X [PitcHsHiFTeR][dada]
197: Arturia - Matrix-12 V v1 1 0 522 R2 AU AAX VST VST3 ST OS X
196: Native Instruments - Maschine Expansion Golden Kingdom HYBRI
195: Arturia - Matrix 12-V v1.0.1.9 OS X [HEXWARS][dada]
194: PPPD-374 Ikuchichi Beauty Salon That Just Busty Beauty Is In
193: THE MATRIX TRILOGY: Complete Collection - DVDRip
...
 10: Matrix Reloaded (2003)Blu-Ray 720p Dublado PT-BR - mo93438
  9: Matrix Revolutions (2003)Blu-Ray 720p Dublado PT-BR - mo9343
  8: Die Matrix Trilogie - 1 bis 3 - KOMPLETT
  7: The Matrix Reloaded (2003) BRRip [Dual Audio] [Hindi+Eng] 50
  6: The Matrix Revolutions (2003) BRRip [Dual Audio] [Hindi+Eng]
  5: Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438
  4: The Matrix Trilogy (1999-2003) BDRip 1080p Dual Audio [ Hind
  3: The Matrix Trilogy (1999-2003) BluRay BDRip 1080p AC3
  2: The Matrix Trilogy (1999-2003) + Extras 1080p BluRay x264 Du
  1: The Matrix Reloaded (2003) FullHD, Dual Audio: English + Spa
  0: Matrix FRENCH DVDRIP 1999 COOL
T
#+END_SRC

    The indexes are  aligned on 3 digits on the  right with =~3@a= and
    titles are truncated at 65 characters,  nice :) It will be easy to
    add more information on the right side (seeders, leechers).


** Getting more torrent information

With =plump:serialize=  we could check  what html is inside  our plump
node:

#+BEGIN_SRC lisp
  (plump:serialize (second res))
  <td class="Title">
  <span class="ColorA">
  <a href="https://piratebay.to/torrent/2297350/Matrix FRENCH DVDRIP 1999 COOL/" onclick="Javascript:OpenDetailPage('https://piratebay.to/torrent/2297350/Matrix FRENCH DVDRIP 1999 COOL/'); return false;">Matrix FRENCH DVDRIP 1999 COOL
  </a>
  </span>
  <br/>
  <span class="ColorB VaA">Upload Date: 05.06.15
  </span>
  <span class="ColorB VaA">Size: 700,30 MB
  </span>
  <span class="ColorB"/>
  </td>
#+END_SRC

We want to get  the torrent's page, the url in  the firts =href=. From
this page we'll be able to access the magnet link.

We know how to access the =a=:

#+BEGIN_SRC lisp
(defparameter *elt* (first res))
(lquery:$ *elt* "a" (text))
;; => #("Matrix FRENCH DVDRIP 1999 COOL")
#+END_SRC

it returns a plump node.

We use =(lquery:$ ... (attr :href))= as seen above to extract attributes:

#+BEGIN_SRC lisp
(lquery:$ *elt* "a" (attr :href))
;; => #("https://piratebay.to/torrent/2297350/Matrix FRENCH DVDRIP 1999 COOL/")
#+END_SRC

Ok. But watch out again, the result is a vector (of one element).

We put this in a function:

#+BEGIN_SRC lisp
(defun detail-page-url (node)
  "Extract the link of the details page. `node': plump node, containing the url."
  (let ((href-vector (lquery:$ node "a" (attr :href))))
     (aref href-vector 0)))
#+END_SRC

which we can test (either write it  at the REPL either write it in the
project and compile, =C-c C-c= in Slime):

#+BEGIN_SRC lisp
(mapcar #'detail-page-url res)  ;; #' is shorthand for function
;; =>
("https://piratebay.to/search/0/800/0/matrix/0/ATitle/1/"
 "https://piratebay.to/torrent/2297350/Matrix FRENCH DVDRIP 1999 COOL/"
 "https://piratebay.to/torrent/2156107/The Matrix Reloaded (2003) FullHD, Dual Audio: English + Spa/"
 "https://piratebay.to/torrent/1885366/The Matrix Trilogy (1999-2003) + Extras 1080p BluRay x264 Du/"
[…]
#+END_SRC

*** To the magnet link

We have the torrent's details page, we  know how to request it, now we
want to get the magnet link.

We experiment, and get a /list/ of the links inside this page.

This is what we first came up with: (can be simpler)

#+BEGIN_SRC lisp
(mapcar (lambda (it)
          (lquery:$ it (attr  :href)))
        (coerce (lquery:$ * "a") 'list))
;; =>
(NIL NIL NIL NIL NIL NIL NIL "https://piratebay.to/" "https://piratebay.to/"
 […]
 "http://imdb.com/title/tt1778413/" "https://piratebay.to/profile/Anonym"
 "https://piratebay.to/Downloader.php?ID=2289391&Filename=Matrix+FRENCH+DVDRIP+1999+COOL"
 "magnet:?xt=urn:btih:40eca43690cf1b99b0a4d485ebf4855d20b0bac5" "http://"
 […]
 "https://twitter.com/piratebayto" "https://www.facebook.com/thepiratebayto"
 "http://bitcoin.org" "bitcoin:1FX2wz8NiWPdtCGSrzn7j3NAg4VKqGovto" "/")
#+END_SRC

in the result, there's our magnet link.

At first I was frustrated to have to =coerce= something to a list but
it is not mandatory.

Because =mapcar= expects a list and
lquery  returns a  vector, we had to  transform  lquery's result to a list  with
=coerce=. But we  can  simply  use =map=,  that  works  on lists  and
vectors, and ask it to return a list:

#+BEGIN_SRC lisp
(map 'list (lambda (it)
             (lquery:$ it (attr  :href)))
           (lquery:$ * "a"))
#+END_SRC

I  find the  name  =mapcar= unusual  too, it  was  frustrating at  the
beginning but it's a just a name after all.

We could also use [[https://lispcookbook.github.io/cl-cookbook/cl21.html][cl21]]'s =map=, which works on lists and vectors so no
more questions, it will work.

Still with cl21, we can write shorter lambdas, with the shorthand =lm=
or with the =^= reader  macro and accessing arguments with =%1=... =%n=
or simply =%= for the first one:

#+BEGIN_SRC lisp
(map ^(lquery:$ % (attr :href)) ...)
#+END_SRC

We filter the list above to extract the magnet link:

#+BEGIN_SRC lisp
(remove-if-not (lambda (it)
                 (str:starts-with? "magnet" it))
               *)
#+END_SRC

Here, I  used again a short  verb from an external  library for string
manipulation. The CL way would be something like:

#+BEGIN_SRC lisp
(string= "magnet-foo" "magnet" :start1 0 :end1 (length "magnet"))
T
#+END_SRC

and yet we must handle nils, differences of length,… so boring.

We end up with  the following functions:


#+BEGIN_SRC lisp
(defun magnet-link-from (node)
  "Extract the magnet link from a `torrent' result."
  (let* ((url (detail-page-url node))
         (html (request-details url))
         (parsed (plump:parse html)))
    (find-magnet-link parsed)))
#+END_SRC


- we extract the magnet link from an  html (the page of a torrent's page)
  parsed with plump like this:

#+BEGIN_SRC lisp
(defun find-magnet-link (parsed)
  "Extract the magnet link. `parsed': plump:parse result."
  (let* ((hrefs (coerce (lquery:$ parsed "a" (attr :href)) 'list))
         (magnet (remove-if-not (lambda (it)
                                  (str:starts-with? "magnet" it))
                                hrefs)))
    (first magnet)))
#+END_SRC

- this one gets  a plump node (from the search  results), extracts the
  url of  the torrent's page and  calls our function above  to extract
  the magnet link:

#+BEGIN_SRC lisp
(defun magnet-link-from (node)
  "Extract the magnet link from a `torrent' result."
  (let* ((url (detail-page-url node))
         (html (dex:get url))
         (parsed (plump:parse html)))
    (find-magnet-link parsed)))
#+END_SRC

- finally we need an easy way to call the function above and give it a
  reference to a search result.

#+BEGIN_SRC lisp
(defun magnet (index)
  "Search the magnet from last search's `index''s result."
  (magnet-link-from (elt *last-search* index)))
#+END_SRC

And we simply use it like so: given an output like

#+BEGIN_SRC text
...
  5: Matrix (1999)Blu-Ray 720p Dublado PT-BR - mo93438
  4: The Matrix Trilogy (1999-2003) BDRip 1080p Dual Audio [ Hind
  3: The Matrix Trilogy (1999-2003) BluRay BDRip 1080p AC3
  2: The Matrix Trilogy (1999-2003) + Extras 1080p BluRay x264 Du
  1: The Matrix Reloaded (2003) FullHD, Dual Audio: English + Spa
  0: Matrix FRENCH DVDRIP 1999 COOL
T
#+END_SRC

    We request the magnet link with:

#+BEGIN_SRC lisp
CL-TORRENTS> (magnet 0)
"magnet:?xt=urn:btih:40eca43690cf1b99b0a4d485ebf4855d20b0bac5"
#+END_SRC


** Exporting functions

We need  to export symbols  in order to use  them from the  outside of
their source  file, in order  to use them directly  (=use-package=) or
with =(my-package:my-function)=. If we don't export them, we can still
access them with a double colon: =(my-package::my-function)=.

Our package definition contains this:

#+BEGIN_SRC lisp
(defpackage cl-torrents
  (:use :cl))
#+END_SRC

We add it an =export= clause:

#+BEGIN_SRC lisp
(defpackage cl-torrents
  (:use :cl)
  (:export :torrents
           :magnet))
#+END_SRC

We could also mark the functions to export with a decorator à-la Python,
like this:

#+BEGIN_SRC lisp
@export
(defun torrents (…)
    …)
#+END_SRC

which  is quite  elegant and  can be  handy. This  is doable  with the
[[https://github.com/m2ym/cl-annot][cl-annot]] library. It also requires a small Slime configuration.

** Conclusion

This leads us to the end of part one.

We wrote a  function that makes a  query on TPB and returns  a list of
Plump objects. Then  the function that prints the  results calls other
ones that extract  the title, the seeders and leechers  from the Plump
objects:  there is  some  coupling  and that  should  be avoided.   In
reality, we quickly changed the =torrents= function so that it returns
a list of alists with the required information extracted:

#+BEGIN_SRC lisp
(defun torrents (words &key (stream t))
  "Search torrents."
  (format stream "searching on the Pirate Bay…")
  (let* ((query (str:join "+" words))
         (*search-url* (str:replace-all "{KEYWORDS}" query *search-url*))
         (req (request *search-url*))
         (html (plump:parse req))
         (res (lquery:$ html *selectors*))
         (toret (map 'list (lambda (node)
                             `((:title . ,(result-title node))
                               (:href . ,(result-href node))
                               (:leechers . ,(result-leechers node))
                               (:seeders . ,(result-peers node))
                               (:source . :tpb)))
                     res)))
    (format stream " found ~a results.~&" (length res))
    toret))

(defun result-title (node)
  "Return the title of a search result."
  (aref
   (lquery:$ node ".Title a" (text))
   0))

(defun result-href (node)
  (let* ((href-vector (lquery:$ node "a" (attr :href))))
    (aref href-vector 0)))
#+END_SRC

That way, the  print function does not rely on  TPB-specific code and
we can give it other alists to print, from other torrent sites.

We now want or need more:

- getting more content (seeders, leechers):  done in the app.
- downloading the torrent file ?
- *error handling* (network errors or timeout, unexpected errors, user
  interrupts)
- scraping other sites, *asynchronously*  (the asynchronous part will be
  straightforward, there's  a library for  that and it's  one function
  change.  See the [[https://lispcookbook.github.io/cl-cookbook/web-scraping.html#async-requests][Cookbook tutorial]].)
- some *cache* (part 6)
- unit tests,  "live" tests and  continuous integration: see  the next
  section.
- building a *standalone executable*, parsing *command line arguments*: see part 3.
- …

We'll carry  on by  writing tests, then  we'll build  a self-contained
executable.


* Tests and CI

We wouldn't be called a developper if we didn't write any test.

Our favorite test framework (which we found on the [[https://github.com/CodyReichert/awesome-cl][Awesome CL list]]) is
[[https://github.com/fukamachi/prove][Prove]].

The file =t/cl-torrents.lisp=, generated by cl-project, looks like this:

#+BEGIN_SRC lisp
(in-package :cl-user)
(defpackage cl-torrents-test
  (:use :cl
        :cl-torrents  ;; => import our exported functions in cl-torrents.lisp
        :prove))      ;; => import all Prove verbs (like python's "from prove import *")
(in-package :cl-torrents-test)

;; NOTE: To run this test file, execute `(asdf:test-system :cl-torrents)' in your Lisp.

(plan nil)  ;; optional Prove setting.

;; blah blah blah.

(finalize)
#+END_SRC

We add our first and simplest test:

#+BEGIN_SRC lisp
(ok (torrents "matrix"))
#+END_SRC

It only checks that this command doesn't fail. We compile it with =C-c
C-c= and we see it run in the REPL.

This  test does  a network  call: it  is not  an unit  test.  It's  an
"end-to-end" test  instead, and  that's ok  we need  one too  :) We'll
write unit  tests now, and  also hide the  large output of  the search
results.


** Unit tests

Since we do webscraping, the result  from the network calls are likely
to  be  different  each  time.    That's  good  for  "integration"  or
"end-to-end" tests but not for unit tests.  We must find a way to fake
the result of =dex:get= and return the same thing, always.

A solution  is to save  a piece of html  in the testing  directory and
make sure  that a call to  =dex:get= returns it. In  other words we're
looking to  mock functions calls.   There's a  library to do  this and
more, [[https://github.com/Chream/mockingbird/][Mockingbird]]:

#+BEGIN_QUOTE
This package provides some useful stubbing and mocking macros for unit
testing.  Used  when specified  functions  in  a  test should  not  be
computed but should instead return a provided constant value.
#+END_QUOTE

It also makes possible to check if  a given function was called, if so
how  many times,  with what  arguments, etc,  which is  very nice  for
tests.

Ok, let's go. We record the html of the search results:

: mkdir t/assets/
: wget  -O t/assets/search-matrix.html https://piratebay.to/search/\?FilterStr\=matrix\&ID\=1\&ID\=\&Limit\=800\&Letter\=\&Sorting\=DSeeder

We need to read this file into a string. A quick look to the Cookbook:
(unfortunately this is not a one-liner :( )

#+BEGIN_SRC lisp
(defun file-to-string (path)
  "Return the given file as a string."
    (with-open-file (stream path
                            :external-format :utf-8)
      (let ((data (make-string (file-length stream))))
        (read-sequence data stream)
        data)))
#+END_SRC

and we use it:

#+BEGIN_SRC lisp
;; Load the search result html from a file.
(defparameter htmlpage (file-to-string #p"t/assets/search-matrix.html"))
#+END_SRC

From mockingbird, we  need =with-dynamic-stubs=. We'll mock  a call to
=dex:get=:

#+BEGIN_SRC lisp
(with-dynamic-stubs ((dex:get htmlpage))
  (ok (torrents "matrix") "torrent search ok"))
#+END_SRC

This test  (run with  =C-c C-c=)  should not make  a network  call and
should  always  return  the  matrix  results.   Indeed,  if  we  write
=(torrents "dysney")= instead it returns (and prints) the same.

So from here, we  can write more unit tests. When we  want to test the
=magnet= function, we  realize that we need to  mock another =dex:get=
call, the one  that requests the html page of  a particular result. We
extract the network  call from the function, what we  should have done
from  the beginning  as best  practice  actually (we'll  also need  to
expand this with error checking and more):

#+BEGIN_SRC lisp
(defun request-details (url)
  "Get the html page of the given url. Mocked in unit tests."
  (dex:get url))
#+END_SRC

Now we mock it. Extending the test above:

#+BEGIN_SRC lisp
(with-dynamic-stubs ((dex:get htmlpage)
                     (cl-torrents::request-details resultpage))

  (ok (torrents "matrix" out) "torrent search ok")

  (ok (str:starts-with? "magnet" (magnet 0))
      "magnet <i> returns the the magnet link from search result."))
#+END_SRC

Our tests  still write a  lot of stuff  on standard output,  let's fix
that.

** Capturing output

We knew giving an optional stream parameter to our =torrents= function
would be useful sometime:

#+BEGIN_SRC lisp
(defun torrents (words &optional (stream t)) ...)
#+END_SRC

The =t=  means "print  to standard  output". The trick  is to  give it
another stream, notably one that goes to a string:

#+BEGIN_SRC lisp
  (ok (with-output-to-string (out)
        (torrents "matrix" out)) "torrent search ok")
#+END_SRC

and that's it, our tests are silent now.

We can write more of them.

** Isolating tests (with a macro)

I'm not bothered (yet?)  by the way we wrote tests  above, all of them
inside  a =with-dynamic-stubs=  macro.  It's just  that  they are  not
isolated,  at each  =C-c  C-c= it  compiled and  ran  the whole  form,
running all our tests.

If we  want, we  can isolate  them, each  one under  its own  and same
=with-dynamic-stubs=. But as soon as  there's repetition… it's time to
refactor with  a macro. There's  not much to it  but we're glad  for a
little practice.

Each test will be of the form:

#+BEGIN_SRC lisp
(with-dynamic-stubs (<stubs>)
    <tests>)
#+END_SRC

The only argument to our macro is a form containing the tests:

#+BEGIN_SRC lisp
(defmacro with-mocked-search-results (body)
#+END_SRC

We get this simple macro:

#+BEGIN_SRC lisp
(defmacro with-mocked-search-results (body)
    `(with-dynamic-stubs ((dex:get htmlpage)
                          (cl-torrents::request-details resultpage))
         ,body))
#+END_SRC

The backquote kind  of warns that there will be  variables inside this
form, and the  coma kind of says  to not evaluate the  argument but to
put it as is.

So when we use it like this:

#+BEGIN_SRC lisp
(with-mocked-search-results
    (ok (with-output-to-string (out)
          (torrents "foo" out))
        "search ok"))
#+END_SRC

we can see how it gets expanded like this:

#+BEGIN_SRC lisp
    (macroexpand-1
     '(with-mocked-search-results ;; <-- note the quote
       (ok (with-output-to-string (out)
             (torrents "foo" out))
        "search ok"))
     )
  ;; (WITH-DYNAMIC-STUBS ((DEXADOR:GET HTMLPAGE)
  ;;                      (CL-TORRENTS::REQUEST-DETAILS RESULTPAGE))
  ;;    (OK (WITH-OUTPUT-TO-STRING (OUT) (TORRENTS "foo" OUT)) "search ok"))
  ;; T
#+END_SRC

Easy :)

** make test

    We must be  able to run tests  from the terminal for  at least two
    reasons:
 - given the moving  state of our Lisp image during  development it is
   possible we get to a state that does not reflect the app at startup
   (for  example,  given  that  a =defparameter=  symbol  doesn't  get
   re-evaluated  with =C-c  C-c=, are  you not  tempted to  =setf= its
   value for testing ?)
 - Continuous Integration
 - I find it handy (that's not a solid reason though).

   We have a  look at Prove's page and  we see that we can  run a test
   file with

: (prove:run #P"myapp/tests/my-test.lisp")

   Then we need to think about the  steps needed when we arrive into a
   new SBCL repl.

- we need to find our system definition.

: (load #P"cl-torrents.asd")

- we need  to make all its symbols and  dependencies available in the
   image.

: (ql:quickload "cl-torrents")  ;; given we have Quicklisp installed and started with SBCL.

- run the test suite.

- quit the REPL.

   That gives this make target:

#+BEGIN_SRC lisp
test:
	sbcl --load cl-torrents.asd \
	     --eval '(ql:quickload :cl-torrents)' \
	     --eval '(prove:run #P"t/cl-torrents.lisp")' \
	     --eval '(quit)'
#+END_SRC

#+html: <p align='center'><img src='img-running-tests.png' /></p>

We can also have a look at [[https://github.com/fukamachi/prove/blob/master/roswell/run-prove.ros][the run-prove Roswell utility]].

Continuous Integration is well explained here:

- [[http://lisp-lang.org/learn/continuous-integration][http://lisp-lang.org/learn/continuous-integration]]


We'll finish with  a note on Prove. It  is easy to use and  the doc is
ok,  but  we  were  surprised  that the  tests  output  are  not  very
informative (we don't have an example  right now though).  So we might
as  well either  try [[https://github.com/fukamachi/rove][Fukamashi's  Rove]], "intended  to be  Prove's next
major release",  either try [[https://github.com/Shinmera/parachute][Shinmera's Parachute]],  which we discovered
only recently.   Parachute also  has includes basic  fixtures support,
test suite dependencies, conditionals, time  limits (also in Prove ?),
silent output, and interactive reports.

On a positive note, kuddos to Mockingbird it was very helpful.

** Continuous Integration

    Now that we have tests running  on the terminal, we'll want to run
    them automatically. We  probably want to run them  on every commit
    but we could choose only  on every tag, periodically (every sunday
    night), or just manually with a command in a commit message.

    We'll use [[https://docs.gitlab.com/ce/ci/README.html][Gitlab's CI]], which is free for public or private repos.

    Gitab  CI works  with  Docker  images so  we'll  use the  existing
    [[https://hub.docker.com/r/daewok/lisp-devel/][daewok/lisp-devel]] one.  It  includes SBCL, ECL, CCL  and ABCL, and
    has Quicklisp  installed in  the home  (=/home/lisp/=), so  we can
    =quickload= packages  right away.  It  also has a more  bare bones
    option.

    We used this example =.gitlab-ci.yml= successfully:

#+BEGIN_SRC text
image: daewok/lisp-devel

before_script:
  - apt-get update -qy
  - apt-get install -y git-core
  - git clone https://github.com/Chream/mockingbird ~/quicklisp/local-projects/

test:
  script:
    - make test
#+END_SRC

- "image": we set which Docker image to use.
- "test": just the name of our pipeline.
- "script":  this is  the  recognized  section to  run  any script  we
  want. If it exits with success,  our pipeline passes. So here we run
  our own "make  test" command (Gitlab has cloned our  project and put
  us at its root for us).
- "before_script": our tests rely on a library that isn't on Quicklisp
  yet, so  we clone  it into the  usual =~/quicklisp/local-projects/=.
  We have to update apt's cache and install git beforehand.

  And this  is it  ! You  know have  a working  continuous integration
  stack.

  But while we're  at it, let's see a couple  more Docker commands and
  a way to test our CI commands locally.

** A couple Docker commands

    We have a  Docker image ready to  use, so let's see how  to use it
    ourselves. Run:

: sudo service docker start
: docker run --rm -it daewok/lisp-devel:latest bash

   This will download what's needed  for the first time (around 400Mo)
   and  then drop  you into  a bash  prompt. Now  you are  in a  fresh
   Debian-based system  with Lisp  stuff installed.  You can  enter an
   =sbcl= REPL  and install  Quicklisp libraries.  But you  don't have
   access to your code outside of Docker. Mount it:

: docker run --rm -it -v /path/to/local/code:/usr/local/share/common-lisp/source daewok/lisp-devel:latest bash

   This will  put your local =/path/to/local/code/=  into Docker where
   indicated.

   Now  we can  test  things around.  I  don't know  how  to test  our
   =.gitlab-ci.yml= straight away though.

   Also see  the Lisp image's README,  they have more stuff  on how to
   develop from our Emacs on the Lisp environment inside the image.


* Building and delivering self-contained executables

** SBCL.

   So far  we used the  =torrents= command  in our Slime  REPL. That's
   fine and  well, but what if  we want to distribute  our software to
   users and simply run it from the shell ?

   Building  (self-contained)  executables is  implementation-specific
   (Rowsell fixes that). With SBCL, as says [[http://www.sbcl.org/manual/index.html#Function-sb_002dext_003asave_002dlisp_002dand_002ddie][its documentation]], it is a
   matter of:

#+BEGIN_SRC lisp
(sb-ext:save-lisp-and-die #P"torrents" :toplevel #'main :executable t)
#+END_SRC

   where =#p"torrents"= is the pathname of the executable, =:toplevel=
   is  the   function  to  be   called  ("entry  point"   in  Python),
   =:executable  t=  tells  to  build  an  executable  instead  of  an
   image. We  could build an  image to save  the state of  our current
   Lisp image, to come back working with it later. Specially useful if
   we made a lot of work that is computing intensive.

   =sb-ext= is an SBCL extension to run external processes.  See other
   [[http://www.sbcl.org/manual/index.html#Extensions][SBCL extensions]]  (many of them are  made implementation-portable in
   other libraries).

   We  have  to  define  a  main function  that  accepts  keywords  as
   arguments (we won't parse command line options just yet).

   The [[https://lispcookbook.github.io/cl-cookbook/os.html#accessing-the-command-line-arguments][Cookbook]] has us covered  once again and, double coincidence, we
   rely  on  SBCL's  =sb-ext=  to  access the  list  of  command  line
   arguments with =sb-ext:*posix-argv*= (this  is not portable yet but
   Roswell  fixes that,  follow  the  recipe). It  returns  a list  of
   arguments,  the first  one being  the  name of  the executable,  as
   usual.

   That gives:

#+BEGIN_SRC lisp
(defun main ()
  "Get command line arguments with SBCL."
  (torrents (subseq sb-ext:*posix-argv* 1)))
#+END_SRC

   Here we give  a list to =torrents=  so you may want to  change it a
   bit  to accept  both  lists and  a string  (from  the user  calling
   directly =(torrents "foo bar")= in Slime):

#+BEGIN_SRC lisp
(defun torrents (words &optional (stream t))
  "Search torrents."
  (let* ((terms (if (listp words)
                    words
                    ;; The main gives words as a list,
                    ;; the user at the Slime REPL one string.
                    (str:words words)))
#+END_SRC

   Cool we  have basic command line  arguments ! We'll parse  them for
   real shortly.

   Another thing to know about =save-lisp-and-die= is that we must run
   this function in another REPL than Slime.

   So, let's launch an SBCL repl at our project root:

: rlwrap sbcl

   (rlwrap gives repl history. The default SBCL repl is the most basic
one).

   If  we  run =save-lisp-and-die=  directly,  we'll  get errors  that
   "cl-torrents  package  does  not  exist",  or  that  "The  function
   COMMON-LISP-USER::MAIN is undefined". Indeed, as is SBCL has no way
   to  know  where is  our  system.  We need  to  load  our asd  file,
   quickload our system  and now that the ongoing image  knows all the
   dependencies an symbols, we can create an executable out of it.

#+BEGIN_SRC lisp
(load "cl-torrents.asd")
(ql:quickload :cl-torrents)
(use-package :cl-torrents)
(sb-ext:save-lisp-and-die #p"torrents" :toplevel #'main :executable t)
#+END_SRC

   Obviously we want this in a Makefile.

** make build

   sbcl has the =--eval= and =--load= options.

#+BEGIN_SRC text
build:
	sbcl --load cl-torrents.asd \
	     --eval '(ql:quickload :cl-torrents)' \
	     --eval '(use-package :cl-torrents)' \
             --eval "(sb-ext:save-lisp-and-die #p\"torrents\" :toplevel #'main :executable t)"
#+END_SRC

   Now a =make build= will take the time to quickload the dependencies
   and build our executable. We can try it on the shell and give it to
   anyone, they won't have any dependency  to install, not even a Lisp
   implementation.

   Let's  realize what  we achieved  for a  moment. Personally  I was
   unable to  do something  like this with  my other  languages before
   (Python, JS).

   And it works for  web apps too ! We just need one  more line in the
   main function, like this:

#+BEGIN_SRC lisp
;; https://stackoverflow.com/questions/30422451/sbcl-deploying-hunchentoot-application-as-executable
(sb-thread:join-thread (find-if (lambda (th)
                                (search "hunchentoot" (sb-thread:thread-name th)))
                              (sb-thread:list-all-threads))))
#+END_SRC

   And we can embed a webapp in Electron for the desktop ! (with Ceramic).

   Are there downsides ?

** Size and startup times of executables per implementation

#+BEGIN_SRC text
$ ls -lh torrents
-rwxr-xr-x 1 vince vince 69M sept. 30 22:58 torrents
#+END_SRC

   Our  executables  weighs  69Mo.  Quite big  for  this  little  cli
   app. But it will be totally ok for a business application.

   To ease the distribution of apps to people who already have a Lisp,
   we  can use  Roswell: we  need to  register our  app in  Quicklisp,
   install   Roswell  and   install  a   program  with   =ros  install
   cl-torrents=.

   SBCL  isn't the  only Lisp  implementation though.  [[https://gitlab.com/embeddable-common-lisp/ecl/][ECL]], Embeddable
   Common  Lisp, compiles  Lisp programs  to C.  That should  create a
   smaller executable.

   Given  [[https://www.reddit.com/r/lisp/comments/46k530/tackling_the_eternal_problem_of_lisp_image_size/][this  reddit  comment]],  ECL  produces  indeed  the  smallest
   executables of all,  an order of magnituted smaller  than SBCL, but
   with a startup time an order of magnitude slower (or more).

#+BEGIN_QUOTE
ECL is particularly suited to this task. Since it transpiles to C, the
C compiler  will remove dead code  automatically for you. You  can get
incredibly small executables this way.
#+END_QUOTE

| program size | implementation |  CPU | startup time |
|--------------+----------------+------+--------------|
|           28 | /bin/true      |  15% |        .0004 |
|         1005 | ecl            | 115% |        .5093 |
|        48151 | sbcl           |  91% |        .0064 |
|        27054 | ccl            |  93% |        .0060 |
|        10162 | clisp          |  96% |        .0170 |
|         4901 | ecl.big        | 113% |        .8223 |
|        70413 | sbcl.big       |  93% |        .0073 |
|        41713 | ccl.big        |  95% |        .0094 |
|        19948 | clisp.big      |  97% |        .0259 |

   We may have another trick  to distribute small executables: to make
   the fasl files executables.

#+BEGIN_QUOTE
This will basically mean that  your on-disk utilities will not include
a copy of the SBCL core but  use the central copy on the system, which
makes  them  relatively  small.  Memory footprint  will  be  the  same
though.
#+END_QUOTE

   So we have room for improvement.

# ** With ECL

# TODO !

# https://common-lisp.net/project/ecl/static/ecldoc/Extensions.html#Executable

# https://stackoverflow.com/questions/46520876/building-an-executable-with-ecl-missing-dependency-or-can-not-find-make-build-i

** Parsing command line arguments

   We   saw   earlier   that    SBCL   stores   the   arguments   into
   =sb-ext:*posix-argv*=.  The first  thing  is that  it differs  from
   implementations, so we want a library to handle the differences for
   us.

   We also want to parse them.

   A  quick  look  at  the [[https://github.com/CodyReichert/awesome-cl#scripting][awesome-cl#scripting]]  list  and  we'll  try
   [[https://github.com/mrkkrp/unix-opts][unix-opts]].

: (ql:quickload "unix-opts")

   We can call it with its =opts= alias (nickname).

   =unix-opts=    allows    to     declare    the    arguments    with
   =opts:define-opts=:

#+BEGIN_SRC lisp
(opts:define-opts
    (:name :help
           :description "print this help text"
           :short #\h
           :long "help")
    (:name :nb-results
           :description "maximum number of results to print."
           :short #\n
           :long "nb"
           :arg-parser #'parse-integer)
    (:name :magnet
           :description "get the magnet link of the given search result."
           :short #\m
           :long "magnet"
           :arg-parser #'parse-integer))
#+END_SRC

   Here =parse-integer= is a built-in CL function.

   We  parse and  get  them with  =opts:get-opts=,  which returns  two
   values: the first  is the list of valid options  and the second the
   remaining free arguments. We then must use =multiple-value-bind= to
   catch everything:

#+BEGIN_SRC lisp
  (multiple-value-bind (options free-args)
      ;; opts:get-opts returns the list of options, as parsed,
      ;; and the remaining free args as second value.
      ;; There is no error handling yet (specially for options not having their argument).
      (opts:get-opts)
      ...
#+END_SRC

    We can  explore this by giving  a list of strings  (as options) to
    =get-opts=:

#+BEGIN_SRC lisp
(multiple-value-bind (options free-args)
                   (opts:get-opts '("hello" "-h" "-n" "1"))
                 (format t "Options: ~a~&" options)
                 (format t "free args: ~a~&" free-args))
Options: (HELP T NB-RESULTS 1)
free args: (hello)
NIL
#+END_SRC

   If we  put an unknown option,  we get into the  debugger. We'll see
   error handling later on.


   So =options= is a [[https://lispcookbook.github.io/cl-cookbook/data-structures.html#plist][property list]],  i.e. a list that alternates a key
   and a value. It helps me to see that it looks like this:

#+BEGIN_SRC text
[o|o]---[o|o]---[o|o]---[o|/]
 |       |       |       |
FOO     "foo"   BAR     "bar"
#+END_SRC

   We can use =getf=  and =setf= with plists, so that's  how we do our
   logic. Below we print the help with =opts:describe= and then =exit=
   (portable way).

#+BEGIN_SRC lisp
  (multiple-value-bind (options free-args)
      ;; No error handling yet (for unknown options or one not having its argument).
      (opts:get-opts)

    (if (getf options :help)
        (progn
          (opts:describe
           :prefix "CL-torrents. Usage:"
           :args "[keywords]")
          (opts:exit))) ;; <= exit takes an optional return status.
    (if (getf options :nb-results)
        (setf *nb-results* (getf options :nb-results)))

    (torrents free-args)

    (if (getf options :magnet)
        ;; if we had caching we wouldn't have to search for torrents first.
        (progn
          (format t "~a~&" (magnet (getf options :magnet)))
          (opts:exit))))
#+END_SRC

   The  example in  the unix-opts  repository suggests  a macro  to do
   slightly better. And there is no error handling yet.

   Here we are. We can build programs that run both in the REPL (well,
   that's obvious) and in the terminal.

   If you like this and want more shiny stuff:

- [[https://github.com/mrkkrp/cl-ansi-term][cl-ansi-term]]  - print  colorized  text,  horizontal lines,  progress
  bars, list,  tables,… [[https://github.com/mrkkrp/shtookovina][shtookovina]] by  the same author is  an example
  command-line app that makes good use of it.
- [[https://github.com/mrkkrp/cl-readline][cl-readine]] -  bindings to  the GNU Readline  library (Emacs  and Vim
  input modes, history, basic expansion,…).
- the Awesome-cl/scripting link above.

** Automatically building and delivering the executable

   We already have a continuous integration system with Gitlab CI (see
   above, Tests and  CI). We're then very close in  having a system to
   automatically build and deliver  our executable. Moreover, we'll do
   that only when we push a new tag.

   For this, we'll declare a [[https://docs.gitlab.com/ce/user/project/pipelines/job_artifacts.html][job artifact]].

   First, we create a new job to run our command that builds the executable:

#+BEGIN_SRC text
build:
  script:
    - make build
#+END_SRC

   We'll see:

#+html: <p align='center'><img src='img-ci-build.png' /></p>

   To be able to browse the artifacts,  and get an url to download the
   last one, we add:

#+BEGIN_SRC text
build:
  script:
    - make build
  artifacts:
    paths:
      - torrents
#+END_SRC

   And now, to only to this on a new tag:

#+BEGIN_SRC text
build:
  only:
    # Only when a new tag is pushed.
    - tags
  script:
    - make build
  artifacts:
    paths:
      - torrents
#+END_SRC

(see
[[https://docs.gitlab.com/ce/ci/yaml/README.html#only-and-except-simplified][the doc]]).

We'll add the rule to run tests first and to not build the software if
they  fail (we  use [[https://docs.gitlab.com/ce/ci/environments.html][environments]]). We declare  two names  of "stages"
(test and build) that respect the  given order, and add a "stage: xxx"
in each job. Our final =.gitlab-ci.yml= is this:

#+BEGIN_SRC text
image: daewok/lisp-devel

stages:          # <= new
  - test
  - build

before_script:
  - apt-get update -qy
  - apt-get install -y git-core
  - git clone https://github.com/Chream/mockingbird ~/quicklisp/local-projects/

test:
  stage: test     # <= new
  only:

  - tags
  script:
    - make test

build:
  stage: build    # <= new
  only:
    # Only when a new tag is pushed.
    - tags
  script:
    - make build
  artifacts:
    paths:
      # xxx include the version number
      - torrents
#+END_SRC

   And  voilà, that's  it.

   We  have an  url  to  download the  latest
   artifact:

#+BEGIN_SRC text
https://gitlab.com/vindarel/cl-torrents/-/jobs/artifacts/master/raw/torrents?job=build
#+END_SRC

   Let's just put  the link on an  icon and add the  version number on
   the executable's name.


** Final words

   As said  before, we didn't do  error handling yet, and  this can be
   annoying in the shell: on an  error, including an user's =C-c=,
   we get a  stacktrace and we are dropped into  the Lisp debugger. We
   fix this below.

* Moving functions into their own package

  We have  written a  few helpers  functions to  treat with  colors of
  keywords.  As we were trying out  things, we wrote those in our main
  file.  But we'd  like them  to go  into their  own "utils"  file and
  package.

  (If you want to see the helper functions, go to the next section.)

** Dealing with symbol conflicts. shadowing-import, uninterning.

   We move them in a new =src/utils.lisp= file.

   Our =utils.lisp=  file declares  a new  =cl-torrents.utils= package,
   exporting what's needed:

#+BEGIN_SRC lisp
(in-package :cl-user)
(defpackage cl-torrents.utils
  (:use :cl)
  (:export :sublist
           :helper-function-one))

(in-package :cl-torrents.utils)
#+END_SRC

  We add this file to the =.asd=:

#+BEGIN_SRC lisp
  :components ((:module "src"
                :components
                ((:file "utils")  ;; <= added
                 (:file "cl-torrents"))))
#+END_SRC

  And on the other side  into =cl-torrents.lisp=, either we =:use= all
  the =export='ed utilities:

#+BEGIN_SRC lisp
  (:use :cl
        :cl-torrents.utils)
#+END_SRC

  either we import  explicitely what we need (and we'll  do that as it
  is more explicit, although a bit redondant):

#+BEGIN_SRC lisp
(defpackage cl-torrents
  (:use :cl)
  (:import-from :cl-torrents.utils
                :colorize-all-keywords
                :keyword-color-pairs
                :sublist)
  …
#+END_SRC

  And then, as we =quickload=  cl-torrents with its new organization,
  we get trapped trapped into the debugger:

#+BEGIN_SRC text
IMPORT CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS causes
name-conflicts in #<PACKAGE "CL-TORRENTS"> between the following
symbols:
  CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS,
  CL-TORRENTS::KEYWORD-COLOR-PAIRS
   [Condition of type SB-EXT:NAME-CONFLICT]
See also:
  Common Lisp Hyperspec, 11.1.1.2.5 [:section]

Restarts:
 0: [SHADOWING-IMPORT-IT] Shadowing-import CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS, uninterning KEYWORD-COLOR-PAIRS.
 1: [DONT-IMPORT-IT] Don't import CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS, keeping KEYWORD-COLOR-PAIRS.
 2: [RESOLVE-CONFLICT] Resolve conflict.
 3: [RETRY] Retry compiling #<CL-SOURCE-FILE "cl-torrents" "src" "cl-torrents">.
 4: [ACCEPT] Continue, treating compiling #<CL-SOURCE-FILE "cl-torrents" "src" "cl-torrents"> as having been successful.
 5: [RETRY] Retry ASDF operation.
 […]
#+END_SRC

  Fortunately there's nothing to be afraid  of, it is pretty clear. We
  have a name conflict between those two symbols:

#+BEGIN_SRC text
  CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS,
  CL-TORRENTS::KEYWORD-COLOR-PAIRS
#+END_SRC

- the first one being our new function into its new =cl-torrents.utils= package,
- the  second being  the  old  one, that  was  into cl-torrents'  main
  file. The function has been moved, but the symbol is still around !

  We need  to give priority  to the new  symbol, and that's  just what
  offers    the   first    restart    n° =0=,    to   "shadow    import
  CL-TORRENTS.UTILS::KEYWORD-COLOR-PAIRS,                  uninterning
  KEYWORD-COLOR-PAIRS.". "uninterning"  is getting rid of  the symbol,
  shadowing-import is this  process to import a symbol  that hides one
  already present.

  We can press =0= and… we get  the same messages.  This time, for the
  other function that was being called directly in our main lisp code.
  We  don't get  this  debugger for  the "intermediate" functions  like
  =next-color=, the ones that are called only by the two main ones.

  It was quick for two warnings. Still,  we could use a way to see and
  accept everything in a row.

** The helper functions. Ansi colors. Closures. Looping over a plist.

   This was fun  to do. Our goal  was to colorize each  keyword with a
   different color, like so:

#+html: <p align='center'><img src='img-colored-results.png' /></p>

  This helps seeing the most  relevant results, because sometimes the
  Pirate Bay  website (at  least this copy)  returns not  very related
  results.

  We have  the list of searched  keywords in =*keywords*=. We  want to
  associate each one with a different color.

  We use the  [[https://github.com/pnathan/cl-ansi-text][cl-ansi-text]] library, on Quicklisp. It  offers to either
  colorize strings like this:

#+BEGIN_SRC lisp
(with-color (:red)
    (princ "Gets printed red..."))
#+END_SRC

  where =:red= is a CL symbol, or with functions:

#+BEGIN_SRC lisp
(import 'cl-ansi-text:yellow)
(yellow "Yellow string")
#+END_SRC

   we'll prefer this method as we are treating with text.

   We are  dealing with ansi colors  in the terminal (either  Slime or
   the terminal).  So what  this does  is adding  an extra  prefix and
   suffix to our string:

#+BEGIN_SRC lisp
(yellow "yellow"
;; "[33myellow[0m"
#+END_SRC

  We have to remember this.

   We define the available colors into a variable:

#+BEGIN_SRC lisp
(defparameter *colors* '(
                         cl-ansi-text:blue
                         cl-ansi-text:green
                         cl-ansi-text:yellow
                         cl-ansi-text:cyan
                         cl-ansi-text:magenta
                         cl-ansi-text:red
                         )
  "Functions to colorize text.")
#+END_SRC

  There  are 6  of them.  Now we  want a  way to  give each  keyword a
  different color. And if we have  more than 6 keywords, we cycle over
  the list. We want  a function to cycle through a  list… but it would
  not start at 0 everytime… that reminds me of closures !

#+BEGIN_SRC lisp
;; closure to loop over the list of available colors.
(let ((index 0))
  (defun next-color ()
    "At each call, return the next color of the list -and start over. Uses *colors*."
    (let ((nb-colors (length *colors*))
          (color (elt *colors* index)))
      (incf index)
      (if (>= index nb-colors)
          (setf index 0))
      color))

  (defun reset-color ()
    (setf index 0))
  )
#+END_SRC

  The function =next-color=  uses the =index= that  is defined outside
  of it  (and which is  still not global,  but internal to  this =let=
  only). So every  time we call =next-color=, =index= is  where it had
  been  left.  Cool  !  I'd  have  used a  class for  this in  another
  language I guess.

  We define a function to associate a color to a keyword:

#+BEGIN_SRC lisp
(defun keyword-color-pairs (&optional (keywords *keywords*))
  "Associate each keyword with a different color and return a list of pairs."
  (mapcar (lambda (it)
            `(,it . ,(next-color)))
          keywords))
#+END_SRC

  A good use of backquotes and comas.

  We have a function to colorize  a keyword inside a given string with
  a color:

#+BEGIN_SRC lisp
(defun colorize-keyword-in-string (title keyword color-f)
  "Colorize the given keyword in the title.
Keep the letters' possible mixed up or down case.
`color-f': color function (cl-ansi-text)."
  ;; It colorizes only the first occurence of the word.
  ;;
  ;; We begin by looking if the string contains our keyword. "search" returns the index.
  (let ((start (search keyword (string-downcase title) :test #'equalp))) ;; case insensitive
    (if (numberp start)
      ;; if "start" is not nil, we get the position of the last letter of the keyword in the string.
      (let* ((end (+ start (length keyword)))
             ;; and we extract the substring.
             ;; In doing so we keep the original case of each letter.
             (sub (subseq title start end))
             ;; We all our color function.
             (colored-sub (funcall color-f sub)))
        ;; We replace the substring with the colored substring, and return it.
        (str:replace-all sub colored-sub title))
      title)))
#+END_SRC

  And we do the same for all keywords. Looping over a plist is easy:

: (loop for (word . color) in keywords-color
:    do (...

#+BEGIN_SRC lisp
(defun colorize-all-keywords (title kw-color)
  "Colorize all the user's search keywords in the given title.
`kw-color': list of pairs with a keyword and a color (function)."
  (let ((new title))
    (loop for (word . color) in kw-color
       do (progn
            (setf new (colorize-keyword-in-string new word color))))
    new)
  )
#+END_SRC

  (anyone have a functional version, with =reduce= maybe ?)

  Now we're happy, we run a search query again and… damn, everything's
  colorized but  the seeders and leechers are not  aligned any more
  :( Indeed, we print our search results with a format string:

: (format stream "~3@a: ~65a ~3@a/~3@a~%" index title-colored seeders leechers)

  See the fixed 65 ? But  our colored titles have different sizes, due
  to the ansi prefixes and suffixes :(

** Formatting a format string

   No big deal ! We have to  adapt this "65", by adding the difference
   of length between the normal title and the colored one.

#+BEGIN_SRC lisp
            (let* ((title (result-title it))
                   (title-colored (colorize-all-keywords title *keywords-colors*))
                   (title-padding (+ 65
                                     (- (length title-colored)
                                        (length title))))
#+END_SRC

   But how  can we insert a  variable in lieu  of "65" ? If  we insert
   another  =~a=,  it  will  print  the number  but  it  will  not  be
   interpreted  as an  option of  the format  directive… we  will then
   format the format string.

   In the following, =~~= is the  directive to print a =~=, so =~~~aa=
   with  the padding  as argument  will  render as  =~65a= (or  =~75a=
   depending on the new length).

#+BEGIN_SRC lisp
(defun display-results (&optional (results *last-search*) (stream t))
  "Results: list of plump nodes. We want to print a numbered list with the needed information (torrent title, the number of seeders,... Print at most *nb-results*."
  (mapcar (lambda (it)
            (let* ((title (result-title it))
                   (title-colored (colorize-all-keywords title *keywords-colors*))
                   (title-padding (+ 65
                                     (- (length title-colored)
                                        (length title))))
                   ;; ~~ prints a ~ so here ~~~aa with title-padding gives ~65a or ~75a.
                   (format-string (format nil "~~3@a: ~~~aa ~~3@a/~~3@a~~%" title-padding)))

              (format stream format-string
                    (position it *last-search*)
                    title-colored
                    (result-peers it)
                    (result-leechers it))))
           (reverse (sublist results 0 *nb-results*)))
  t)
#+END_SRC

To see the larger picture, see [[https://github.com/vindarel/cl-torrents/blob/0a1965d61cd330d0b202b9659bf6963a4f8abb32/src/cl-torrents.lisp#L117][=display-results=]] on the repository.
* Error handling
** Dealing with malformed command line arguments

   If you try to give a bad  argument on the command, you'll enter the
   debugger.  Obviously, we  prefer to  print an  informative message,
   print the help and exit.

   =unix-opts=  will  throw  (or  rather  /signal/)  conditions  (hear
   "exceptions" if you wish) on malformed options:

- =opts:unknown-option=,
- =opts:missing-arg=,
- =opts:parser-failed=  and
- =opts:missing-required-option=.

   It also has a complete example. This library is really nice.

   The general form of condition handling is to use =handler-bind=:

#+BEGIN_SRC lisp
(handler-bind ((one-condition #'its-handler)
               (another-condition #'another-handler))
   (some code))
#+END_SRC

    where we are in charge in  writing the =#'handlers=. They take the
    =condition=  object as  argument.  We  give them  below. They  use
    =opts:describe=  to  print  the help  message  and  =(opts:raw-arg
    condition)=  to read  the  argument in  cause  from the  condition
    object.

    Yes, conditions are CLOS classes. When we create our owns,
    we   can   define   different   slots,   etc.   The   article   on
    [[https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/][z0ltan.wordpress.com]] will tell you more.

#+BEGIN_SRC lisp
(defun unknown-option (condition)
  (format t "~s option is unknown.~%" (opts:option condition))
  (opts:describe
   :args "[keywords]")
  (exit))

(defun missing-arg (condition)
  (format t "Bad options: ~a needs an argument.~&" (opts:option condition))
  (opts:describe
   :args "[keywords]")
  (exit))

(defun arg-parser-failed (condition)
  (format t "Error: could not parse ~a as argument of ~a~&."
          (opts:raw-arg condition)
          (opts:option condition))
  (opts:describe
   :args "[keywords]")
  (exit))
#+END_SRC

   And so we surround the reading of the options with =handler-bind=:

#+BEGIN_SRC lisp
      (handler-bind ((opts:unknown-option #'unknown-option)
                     (opts:missing-arg #'missing-arg)
                     (opts:arg-parser-failed #'arg-parser-failed)
                     ;; (opts:missing-required-option #'...) ;; => in upcoming version
        (opts:get-opts)) ;; <= this will signal conditions, if any.
#+END_SRC

   We can build and try:

#+BEGIN_SRC text
$ ./torrents -p foo
"-p" option is unknown.

Available options:
  -h, --help               print this help text
  -n, --nb ARG             maximum number of results to print.
  -m, --magnet ARG         get the magnet link of the given search result.
#+END_SRC

   And all is well. We didn't catch everything though…

** Catching a user's C-c termination signal

   Let's try a =C-c= and read the stacktrace:

#+BEGIN_SRC text
$ ./torrents matrix
^Csearching on the Pirate Bay…                                 <== C-c
debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT in thread   <== condition name
#<THREAD "main thread" RUNNING {1003156A03}>:
  Interactive interrupt at #x7FFFF6C6C170.

Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE     ] Return from SB-UNIX:SIGINT.               <== it was a SIGINT indeed
  1: [RETRY-REQUEST] Retry the same request.
#+END_SRC

   The  signaled   condition  is   named  after   our  implementation:
   =sb-sys:interactive-interrupt=. We  just have to surround  our code
   with a try/catch or rather, with =handler-case=:

#+BEGIN_SRC lisp
(handler-case
    (torrents free-args)
  (sb-sys:interactive-interrupt () (progn
                                     (format *error-output* "Abort.~&")
                                     (opts:exit))))
#+END_SRC

    This code won't  work with ECL or another  implementation. We know
    about [[https://github.com/guicho271828/trivial-signal/issues][trivial-signal]], but we were  not satisfied with our test (it
    didn't work, see issue #3).

    This will be good for now,  but in case we found portable examples
    on other projects. We could do something like this (thanks [[https://github.com/fukamachi/clack/blob/master/src/clack.lisp#L36][Clack]]):

#+BEGIN_SRC lisp
(handler-case
    <main>
  (#+sbcl sb-sys:interactive-interrupt
   #+ccl  ccl:interrupt-signal-condition
   #+clisp system::simple-interrupt-condition
   #+ecl ext:interactive-interrupt
   #+allegro excl:interrupt-signal
   ()
   <exit>))
#+END_SRC

   here =#+=, you know, includes the line at compile time depending on
   the  implementation.  There's  also =#-=.   Actually =#+=  looks at
   symbols in the =*features*= list.  We can also combine symbols with
   =and=, =or= and =not=.

* More features
** Cache

   We'd like  a cache system.  This was quick  and easy with the
   [[https://github.com/html/clache/][Clache]] library.

   We instantiate a  cache on the file system (a  file per item saved,
   not on a DB):

#+BEGIN_SRC lisp
(defparameter *store* (progn
                        (ensure-directories-exist #p"cache/")
                        (make-instance 'file-store :directory #p"cache/"))
  "Cache for results. The directory must exist.")
#+END_SRC

   this FS  storage is provided by  [[https://github.com/skypher/cl-store][cl-store]]. We could also  create an
   in-memory cache, suitable for memoization.

   Saving  something in  the  cache  and retrieving  it  is made  with
   =(setcache key val store)= and =getcache key store=. We just create
   wrapper  functions, to  print  a little  confirmation message,  and
   because we might want to mock them in unit tests:

#+BEGIN_SRC lisp
(defun save-results (terms val store)
  "Save results in cache."
  (format t "Saving results for ~a.~&" terms)
  (setcache terms val store))

(defun get-cached-results (terms store)
  (when (getcache terms store)
    (progn
      (format t "Got cached results for ~a.~&" terms)
      (getcache terms store))))
#+END_SRC

   and we use it like this:

#+BEGIN_SRC lisp
;; in the middle of `torrents'.
(if (get-cached-results joined *store*)
                 (getcache joined *store*)
                 (tpb::torrents words :stream log-stream))
#+END_SRC

    We re-build the project (=make build=), search for matrix once (we
    wait a bit) and a second time: we hit the cache.

    Quick and easy, tell me if I was /too/ quick !

* Conclusion

  That the end of our tutorial (for now ?).

  You can see the full sources and comment on the repository: https://github.com/vindarel/cl-torrents
